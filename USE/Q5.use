model Q5

class Person
attributes
birthYear : Integer
deathYear : Integer
age : Integer derive:
    if (self.community.clock.NOW <> null) then
        if (self.community.clock.NOW < self.birthYear) then null
        else
            if (self.community.clock.NOW >= self.birthYear and self.community.clock.NOW < self.deathYear) then
                self.community.clock.NOW - self.birthYear
            else
                if (self.community.clock.NOW >= self.birthYear and self.community.clock.NOW >= self.deathYear) then
                    self.deathYear - self.birthYear
                else null
                endif
            endif
        endif
    else null
    endif
estadoMarital : String derive:
    if (self.husband -> size() > 0 and self.genero='Femenino') then 'Casada'
    else
        if (self.wife -> size() > 0 and self.genero='Masculino') then 'Casado'
        else    
            if (self.genero='Femenino') then 'Soltera'
            else
                if (self.genero='Masculino') then 'Soltero'
                else null
                endif
            endif
        endif
    endif
isDead : Boolean derive: 
    self.deathYear <> null implies 
        self.community.clock.NOW <>null implies
            self.community.clock.NOW >= self.deathYear and self.community.clock.NOW >= self.birthYear
estadoEdad : String derive : 
    if (self.age<>null and self.age>= 0) then 
        if (self.age >= 0 and self.age < self.community.edadNinoJoven) then 'Nino' 
        else 
            if (self.age >= self.community.edadNinoJoven and self.age < self.community.edadJovenAdulto) then 'Joven' 
            else
                if (self.age >= self.community.edadJovenAdulto and self.age < self.community.edadAdultoAnciano) then 'Adulto' 
                else
                    if (self.age >= self.community.edadAdultoAnciano) then 'Anciano' 
                    else 'Desconocido'
                    endif
                endif
            endif
        endif
    else 'No nacido'
    endif
genero : String
operations

isMarried(): 
    Boolean =
    self.husband -> exists(m | m.startYear <> null and m.husband -> size() >= 1) or
    self.wife -> exists(m | m.startYear <> null and m.wife -> size() >= 1) --creo que esta ultima linea se podria quitar

marriages(): 
    Integer = self.husband -> size() + self.wife -> size()

cumpleAnos()
    begin
        self.age := self.age + 1;
    end
    pre: self.isDead = false             --Solo se suman años a los vivos

casarseConMarido(marido : Person)
    begin
    declare m : Marriage;
    m := new Marriage;
    insert(self, m) into marryWifeHusband;
    insert(marido, m) into marryHusbandWife;
    marido.estadoMarital := 'Casado';
    self.estadoMarital := 'Casado';
    m.startYear := self.community.clock.NOW;
    m.endYear := null;

    if (not self.solicitado -> isEmpty()) then
            delete(self,marido) from casa;
    end;

        if (not self.solicita -> isEmpty()) then
            delete(marido,self) from casa;
    end;        

    end
    pre: (self.solicita -> exists (p | p = marido) and marido.solicitado -> exists (p | p = self)) or (self.solicitado -> exists (p | p = marido) and marido.solicita -> exists (p | p = self))
    post: not (self.solicita -> exists (p | p = marido) and marido.solicitado -> exists (p | p = self)) or not (self.solicitado -> exists (p | p = marido) and marido.solicita -> exists (p | p = self))

casarseConMujer(mujer : Person)
    begin
    declare m : Marriage;
    m := new Marriage;
    insert(self, m) into marryHusbandWife;
    insert(mujer, m) into marryWifeHusband;
    mujer.estadoMarital := 'Casado';
    self.estadoMarital := 'Casado';
    m.startYear := self.community.clock.NOW;
    m.endYear := null;

    if (not self.solicitado -> isEmpty()) then
            delete(self,mujer) from casa;
    end;

        if (not self.solicita -> isEmpty()) then
            delete(mujer,self) from casa;
    end;        

    end
    pre: (self.solicita -> exists (p | p = mujer) and mujer.solicitado -> exists (p | p = self)) or (self.solicitado -> exists (p | p = mujer) and mujer.solicita -> exists (p | p = self))
    post: not (self.solicita -> exists (p | p = mujer) and mujer.solicitado -> exists (p | p = self)) or not (self.solicitado -> exists (p | p = mujer) and mujer.solicita -> exists (p | p = self))

fallecer()
    begin
    self.deathYear := self.community.clock.NOW;
    self.estadoMarital := 'Muerte';             
    self.isDead := true;
    if (self.isMarried()) then                      --Comprobamos, para finalizar el matrimonio
        if(not self.wife -> isEmpty()) then         --Si tiene mujer
            self.wife -> select(m | m.endYear = null) -> asSequence -> first().wife.estadoMarital := 'Viuda';
            self.wife -> select(m | m.endYear = null) -> asSequence -> first().endYear := self.community.clock.NOW;
        else                                        --Si tiene marido
            self.husband -> select(m | m.endYear = null) -> asSequence -> first().husband.estadoMarital := 'Viudo';
            self.husband -> select(m | m.endYear = null) -> asSequence -> first().endYear := self.community.clock.NOW;
        end;
    else                                             --Borramos las posibles relaciones
        if (not self.solicitado -> isEmpty()) then
            for p in self.solicitado do
                delete (self, p) from casa;
            end;
        end;
        if (not self.solicita -> isEmpty()) then
            for p in self.solicita do
                delete (p, self) from casa;
            end;
        end;
        if (not self.solicitadoDiv -> isEmpty()) then
            delete (self, self.solicitadoDiv) from divorcio;
        end;
        if (not self.solicitaDiv -> isEmpty()) then
            delete (self.solicitaDiv, self) from divorcio;
        end;
    end;

    end
    pre: self.isDead = false
    post: self.isDead = true

proponerDivorcio(persona : Person)
    begin
        insert(self,persona) into divorcio
    end
    pre: (self.husband.exists(p|p.husband=persona) implies persona.wife.exists(p|p.wife=self)) and 
        (self.wife.exists(p|p.wife  =persona) implies persona.husband.exists(p|p.husband=self)) and 
        not self.solicitadoDiv->includes(persona) and not persona.solicitaDiv->includes(self)
    post: self.solicitadoDiv->includes(persona) and persona.solicitaDiv->includes(self)
    

proponerMatrimonio(persona : Person)
    begin
        insert(self,persona) into casa
    end

    pre: (not self.husband.exists(p|p.husband=persona) implies not persona.wife.exists(p|p.wife=self))      --NO DEBERIAS PODER PROPONER SI YA ESTAS CASADO
    and (not self.wife.exists(p|p.wife  =persona) implies not persona.husband.exists(p|p.husband=self) ) and 
         not self.solicitado->includes(persona) and not persona.solicita->includes(self)
    post: self.solicitado->includes(persona) and persona.solicita->includes(self)

casar(persona : Person)
    begin
        if(self.genero='Femenino') then 
            self.casarseConMarido(persona);
        else
            if (self.genero='Masculino') then
            self.casarseConMujer(persona);
            end;
        end;
    end
    pre: self.solicita->includes(persona) and persona.solicitado->includes(self) and (self.genero <> persona.genero) --No aceptamos matrimonios homosexuales!
    post: not self.solicita->includes(persona) and not persona.solicitado->includes(self)

rechazarCasar(persona : Person)
    begin
        delete(persona,self) from casa;
    end
    pre: self.solicita->includes(persona) and persona.solicitado->includes(self)
    post: not self.solicita->includes(persona) and not persona.solicitado->includes(self)

rechazarDivorciar(persona: Person)
    begin
        delete(persona,self) from divorcio
    end
    pre: self.solicitaDiv->includes(persona) and persona.solicitadoDiv->includes(self)
    post: not self.solicitaDiv->includes(persona) and not persona.solicitadoDiv->includes(self)

divorciar(persona : Person)
    begin
    declare m : Marriage;
        if (self.genero='Femenino') then
            m :=self.husband->select(p|p.husband=persona)->asSequence()->first();
            delete (persona,m) from marryHusbandWife;
            delete (self,m) from marryWifeHusband;
            delete(persona,self) from divorcio;
            destroy(m)
        else
            if (self.genero='Masculino') then
                m:=self.wife->select(p|p.wife=persona)->asSequence()->first();
                delete(persona,m) from marryWifeHusband;
                delete(self,m) from marryHusbandWife;
                delete(persona,self) from divorcio;
                destroy(m);
            end;
        end;
    end
    pre: self.solicitaDiv->includes(persona) and persona.solicitadoDiv->includes(self) and 
        (self.husband.exists(p|p.husband=persona) and persona.wife.exists(p|p.wife  =self)) or 
        (self.wife.exists(p|p.wife=persona) and persona.husband.exists(p|p.husband=self))
        and self.genero <> persona.genero
    post: not self.solicitaDiv->includes(persona) and not persona.solicitadoDiv->includes(self)

end

class Marriage
attributes
startYear : Integer
endYear : Integer
end

class Community
attributes
edadNinoJoven : Integer
edadJovenAdulto : Integer
edadAdultoAnciano : Integer
end

class Clock
attributes
NOW: Integer
operations
anoNuevo()
    begin
        self.NOW := self.NOW + 1;
         for p in Person.allInstances() do
            if (p.isDead <> true) then       --Si no hacemos esto, USE parara la ejecucion de la operacion si encuentra a alguien muerto porque no se cumple la precondicion
                p.cumpleAnos();
            end                            
        end
    end
end

association marryWifeHusband between
Person[1] role wife
Marriage[*] role husband
end

association marryHusbandWife between
Person[1] role husband
Marriage[*] role wife
end

association casa between
Person[*] role solicita
Person[*] role solicitado
end

association divorcio between
Person[0..1] role solicitaDiv
Person[0..1] role solicitadoDiv
end

composition perteneceAComunidad between
Community[1] role community --base
Person[*] role person
end

aggregation tiempo between
Community[*] role community --base
Clock[1] role clock
end

constraints
-------------------------------------------------
-------------RESTRICCIONES ALÉTICAS--------------
-------------------------------------------------


--Una persona no puede fallecer antes de nacer.
context Person inv personaNoPuedeMorirAntesDeNacer:
    self.deathYear <> null and self.birthYear <> null implies
        self.deathYear >= self.birthYear

--Un matrimonio no puede acabar antes de empezar.
context Marriage inv matrimonioNoPuedeAcabarAntesDeEmpezar:
    self.endYear<>null implies
        self.endYear >= self.startYear

--Los muertos no pueden estar casados.
context Person inv personaMuertaNoPuedeEstarCasada:
    self.isDead = true implies self.estadoMarital = 'Soltere'

--No se puede nacer en el futuro: Clock.NOW tiene que ser mayor o igual que cualquier fecha de nacimiento.
context Community inv noSePuedeNacerEnElFuturo:
    self.clock.NOW <> null implies
        self.person -> forAll(p | p.birthYear <> null implies p.birthYear <= self.clock.NOW)

--No puede haber matrimonios futuros (“acordados”): Clock.NOW tiene que ser siempre mayor o igual que cualquier fecha de comienzo de un matrimonio.
context Community inv noHayMatrimoniosAcordados:
    self.clock <> null implies
        (self.person.husband<> null implies self.person.husband -> forAll(h | h.startYear <= self.clock.NOW)) and
        (self.person.wife <> null implies self.person.wife -> forAll(w | w.startYear <= self.clock.NOW))

--No se puede divorciar una persona de alguien con quien no esté actualmente casado.
context Person inv noPuedesDivorciarteSiNoEstasCasado:
    self.solicitaDiv <> null implies
    (self.wife.wife -> includes(self) or 
    self.husband.husband -> includes(self))

-------------------------------------------------
-------------RESTRICCIONES DEÓNTICAS-------------
-------------------------------------------------

--No puede haber más que un reloj en toda la aplicación (y por tanto compartido por todas las comunidades)
context Clock inv NumReloj:
Clock.allInstances() -> size = 1

--Una persona no puede estar casada consigo misma
context Person inv autoMatrimonio:
not self.wife -> isEmpty() implies
self.wife -> select(m | m.wife = self) -> isEmpty()                         --Metodo 1
--self.wife.wife -> forAll(p | self <> p)                                   --Metodo 2

--Monogamia: Una persona no puede tener más de un matrimonio activo en un momento dado.
context Person inv monogamia:
  self.wife -> union(self.husband) -> forAll(m1, m2 |                       
    m1 <> m2 implies (                                                      
     (m1.endYear < m2.startYear and m1.startYear < m2.startYear) or 
        (m1.endYear > m2.startYear and m1.startYear > m2.startYear)
    ) --Hacemos un set de todos los matrimonios, y cogemos todas las combinaciones con el forAll. Si no son el mismo matrimonio tiene que cumplir esas condiciones
  )

--Los niños no pueden estar casados.
context Person inv ninoSoltero:
self.age < self.community.edadNinoJoven implies
self.wife -> isEmpty() and self.husband -> isEmpty()


--No se permite ni la eutanasia ni el suicidio.
context Person inv muerteNatural:
self.age < self.community.edadJovenAdulto implies
isDead = false

--La edad en las que las personas cambian de niño a joven, de joven a adulto o de adulto a anciano puede
--depender de la comunidad a la que pertenezca la persona.
--Especificado en el diagrama de clases

-------------------------------------------------
-------------RESTRICCIONES ADICIONALES-----------
-------------------------------------------------

--Una persona solo puede solicitar matrimonio a otra si no está casada
--no se si esta bien, habria que revisarlo
context Person inv solicitaMatrimonioSiNoEstaCasada:
    self.solicita -> forAll(noCasada | noCasada.isMarried() = false)

--El año de muerte de una persona no puede ser menor que el año de su nacimiento
context Person inv fechaMuerteNoPuedeSerMayorAlAnoDeNacimiento:
    self.deathYear<> null implies self.deathYear > self.birthYear

--La edad no puede ser null
context Person inv edadNoPuedeSerNull:
    self.age <> null

--El genero no puede ser null
context Person inv generoNoPuedeSerNull:
    self.genero <> null

--El genero tiene que ser 'Masculino' o 'Femenino'
context Person inv generoTieneQueSerUnoDeLosDos:
    self.genero <> null implies (self.genero='Masculino' or self.genero='Femenino')

